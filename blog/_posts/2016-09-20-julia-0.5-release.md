---
layout: post
title:  Julia 0.5
author: Stefan Karpinski
---

Julia 0.5 is a monumental release. It introduces by far the largest number of transformative features to the language of any Julia release to date. In what follows, I'll go over some of the major changes to areas of the language including: functions, comprehensions, arrays, strings, the standard library, and the broader ecosystem.

## Functions

It took some time for the focus of the 0.5 release to become clear. We had many ideas about what it should contain, but eventually a single theme crystallized that eclipsed the others: *functional programming*. Julia has always been a functional language in the technical sense – functions are values that can pass to and from other functions (i.e. [higher-order functions](https://en.wikipedia.org/wiki/Higher-order_function)) and there is full support for [lambdas](https://en.wikipedia.org/wiki/Anonymous_function). Before this release, however, anonymous and higher-order functions came with a significant performance cost. In a language that targets high-performance technical computing, that's a problem. So the Julia standard library and ecosystem have been full of work-arounds to get the expressiveness of functional programming without the performance problems. But the right solution, of course, is to just make functional programming fast – ideally just as fast as the optimal hand-written version of your code would be. In Julia 0.5, it is. And that changes everything.

### Return type annotations

### No more ambiguous method warnings

Instead, an error is thrown if (and only if) you actually call an ambiguous method.

## Comprehensions & Generators

### Filtering and nesting

### Inference-independence

### Generator expressions

Comprehension-like syntax for yielding values.

## Arrays

### Syntax for vectorized function calls with broadcasting and loop fusion

### "Dim sum" slicing

APL-style array slicing.

### Better array views

### Improved custom array type support

## Strings

### Simplification and unification

## Other

- prime and combinatorics functionality moved into packages
- upgrade of LLVM from version 3.3 to version 3.7.1
- improved [ARM] support and initial support for [Power]
- experimental, scalable threading support
- a powerful interactive debugger

[ARM]: https://en.wikipedia.org/wiki/ARM_architecture
[Power]: https://en.wikipedia.org/wiki/Power_Architecture
