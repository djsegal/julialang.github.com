---
layout: post
title:  Julia 0.5
author: Stefan Karpinski
---

Julia has always been a functional language in the technical sense – functions are values that can pass to and from other functions (i.e. [higher-order functions](https://en.wikipedia.org/wiki/Higher-order_function)) and there is full support for [lambdas](https://en.wikipedia.org/wiki/Anonymous_function). Before Julia 0.5, however, anonymous and higher-order functions came with a significant performance cost. In a language that targets very high-performance technical computing, that's a problem. So the Julia standard library and ecosystem have been rife with work-arounds to get the expressiveness of functional programming without the performance problems. But the right solution, of course, is to just make functional programming fast – ideally just as fast as the optimal hand-written version of your code would be. In Julia 0.5, it is. And that changes everything.

That's not the only change in Julia 0.5, of course. Highlights of the release include:

- efficient anonymous and higher order functions
- generator expressions – like array comprehensions without the array
- filtering and nesting of comprehensions and generators
- comprehensions are now nearly independent of type inference
- syntax for vectorized function calls with broadcasting and loop fusion
- function return type annotations
- experimental (but working and scalable) threading support
- no more ambiguous method warnings; instead an error is thrown if called
- dimension summing ("dim sum") array slicing, aka APL-style
- significant improvements to array views and generic array support
- simplification of built-in string types and functions
- extraction of prime and combinatorics functionality into packages
- upgrade of LLVM from version 3.3 to version 3.7.1
- improved [ARM](https://en.wikipedia.org/wiki/ARM_architecture) support and initial support for [Power](https://en.wikipedia.org/wiki/Power_Architecture)
- a powerful interactive debugger
