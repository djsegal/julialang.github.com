---
layout: post
title:  Julia 0.5
author: Stefan Karpinski
---

Julia has always been a functional language in the technical sense – functions are values that can pass to and from other functions (i.e. [higher-order functions](https://en.wikipedia.org/wiki/Higher-order_function)) and there is full support for [lambdas](https://en.wikipedia.org/wiki/Anonymous_function). Before Julia 0.5, however, anonymous and higher-order functions came with a significant performance cost. In a language that targets very high-performance technical computing, that's a problem. So the Julia standard library and ecosystem have been rife with work-arounds to get the expressiveness of functional programming without the performance problems. But the right solution, of course, is to just make functional programming fast – ideally just as fast as the optimal hand-written version of your code would be. In Julia 0.5, it is. And that changes everything.

That's not the only change in Julia 0.5, of course. Highlights of the release include:

- efficient anonymous and higher order functions
- function return type annotations
- comprehensions support filtering and nesting
- comprehensions are now nearly independent of type inference
- generator expressions – comprehension-like syntax for yielding values
- syntax for vectorized function calls with broadcasting and loop fusion
- no more ambiguous method warnings, an error is thrown on ambiguous calls
- APL-style array slicing – i.e. dimension summing ("dim sum") behavior
- significant improvements to array views and custom array type support
- simplification and unification of string types and functions
- prime and combinatorics functionality moved into packages
- upgrade of LLVM from version 3.3 to version 3.7.1
- improved [ARM](https://en.wikipedia.org/wiki/ARM_architecture) support and initial support for [Power](https://en.wikipedia.org/wiki/Power_Architecture)
- experimental, scalable threading support
- a powerful interactive debugger
