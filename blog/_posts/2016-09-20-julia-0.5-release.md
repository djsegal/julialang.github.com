---
layout: post
title:  Julia 0.5 ("Functopia")
author: Stefan Karpinski
---

Julia has always been a functional language in the technical sense – functions are values that can pass to and from other functions (i.e. [higher-order functions](https://en.wikipedia.org/wiki/Higher-order_function)) and there is full support for [lambdas](https://en.wikipedia.org/wiki/Anonymous_function). Before Julia 0.5, however, anonymous and higher-order functions came with a significant performance cost. In a language that targets very high-performance technical computing, that's a problem. So the Julia standard library and ecosystem have been rife with work-arounds to get the expressiveness of functional programming without the performance problems. But the right solution, of course, is to just make functional programming fast – ideally just as fast as the optimal hand-written version of your code would be. In Julia 0.5, it is. And that changes everything.

That's not the only change in Julia 0.5, of course. Other highlights of the release include:

- generator expressions
- more features for array comprehensions (filters, nesting)
- array comprehensions are now (nearly) independent of type inference
- syntax for vectorized function calls with loop fusion
- function return type annotations
- experimental – but working and scalable! – threading support
- warnings for ambiguous methods only if they're called instead of when they're defined
- APL-style array slicing



- **Generators****Generator expressions**, similar to array comprehensions but producing a sequence of values which can be consumed by functions without creating a temporary array to hold the values. Generators and comprehensions now have more fleshed out functionality, like filtering with `if` and nested iteration with multiple `for` keywords.

- **Vectorized function application with fusion**: 
