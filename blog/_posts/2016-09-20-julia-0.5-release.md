---
layout: post
title:  Julia 0.5
author: Stefan Karpinski
---

Julia 0.5 is a pivotal release. It introduces a large number of transformative features to Julia – more than any other release to date. Moreover, several of these features set the stage for even more to come in the releases of Julia leading up to 1.0 in 2017. In what follows, we'll go through some of the major changes in 0.5, including improvements to functional programming, comprehensions, arrays, strings, the standard library, and tooling.

## Functions

<!--
It took some time for the focus of the 0.5 release to become clear. We had many ideas about what it should contain, but eventually a single theme crystallized that eclipsed the others: *functional programming*.
-->

Julia has always been a functional language in the technical sense – functions are values that can be passed to and from other functions (i.e. [higher-order functions](https://en.wikipedia.org/wiki/Higher-order_function)) and there is full support for [lambdas](https://en.wikipedia.org/wiki/Anonymous_function). Before this release, however, anonymous and higher-order functions came with a significant performance cost, and in a language that targets high-performance technical computing, that's a problem. So the Julia standard library and ecosystem have been rife with work-arounds to get the expressiveness of functional programming without the performance problems. But the right solution, of course, is to just make functional programming fast – ideally just as fast as the optimal hand-written version of your code would be. In Julia 0.5, it is. And that changes everything.

### Return type annotations

You can now annotate method definitions with a return type, like so:

    function clip{T<:Real}(x::T, lo::Real, hi::Real)::T
        if x < lo
            return lo
        elseif x > hi
            return hi
        else
            return x
        end
    end

This has the effect of inserting implicit calls to `convert` to `T` at each return point, in this case ensuring that `clip` always returns a value of the same type as `x`, regardless of the type of `lo` and `hi`:

    julia> clip(0.5, 1, 2)
    1.0
    
    julia> clip(1.5, 1, 2)
    1.5
    
    julia> clip(2.5, 1, 2)
    2.0

You may have noticed that the return type here is `T`, which is a type parameter of the `clip` method. Not only is that allowed, but the return type can be an arbitrary expression of values from the outer scope, argument values, and type parameters. For example:

    function clip2(x::Real, lo::Real, hi::Real)::promote_type(typeof(x), typeof(lo), typeof(hi))
        if x < lo
            return lo
        elseif x > hi
            return hi
        else
            return x
        end
    end

    julia> clip2(2, 1, 3)
    2

    julia> clip2(2, 1, 13//5)
    2//1

    julia> clip2(2.5, 1, 13//5)
    2.5

Return type annotations makes it write methods with consistent and predicatble return types.

### No more ambiguous method warnings

Instead, an error is thrown if (and only if) you actually call an ambiguous method.

## Comprehensions & Generators

### Filtering and nesting

### Inference-independence

### Generator expressions

Comprehension-like syntax for yielding values.

## Arrays

### Syntax for vectorized function calls with broadcasting and loop fusion

### "Dim sum" slicing

APL-style array slicing.

### Better array views

### Improved custom array type support

## Strings

### Simplification and unification

## Other

- prime and combinatorics functionality moved into packages
- upgrade of LLVM from version 3.3 to version 3.7.1
- improved [ARM] support and initial support for [Power]
- experimental, scalable threading support
- a powerful interactive debugger

[ARM]: https://en.wikipedia.org/wiki/ARM_architecture
[Power]: https://en.wikipedia.org/wiki/Power_Architecture
